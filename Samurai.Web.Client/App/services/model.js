define(['config'],
  function (config) {
    var DT = breeze.DataType;
    var AutoGeneratedKeyType = breeze.AutoGeneratedKeyType;
    var nulloDate = new Date(1900, 0, 1);

    var model = {
      configureMetadataStore: configureMetadataStore
    };

    return model;

    function configureMetadataStore(metadataStore) {
      entityTypeInitialiser(metadataStore);
      registerEntityTypeConstructors(metadataStore);
    }

    //#region Private variables
    function entityTypeInitialiser(metadataStore) {
      metadataStore.addEntityType({
        shortName: 'FootballMatch',
        namespace: 'Samurai',
        dataProperties: {
          matchIdentifier: { dataType: DT.String },
          id: { dataType: DT.Int64, isPartOfKey: true },
          league: { dataType: DT.String },
          season: { dataType: DT.String },
          matchDate: { dataType: DT.DateTime },
          homeTeam: { dataType: DT.String },
          awayTeam: { dataType: DT.String },
          scoreLine: { dataType: DT.String },
          iktsGameWeek: { dataType: DT.Int64 },
        },
        navigationProperties: {
          predictions: {
            entityTypeName: 'FootballPrediction',
            isScalar: true,
            associationName: 'FootballMatch_FootballPrediction'
          },
          odds: {
            entityTypeName: 'FootballOdds',
            isScalar: true,
            associationName: 'FootballMatch_FootballOdds'
          }
        }
      });

      metadataStore.addEntityType({
        shortName: 'FootballPrediction',
        namespace: 'Samurai',
        dataProperties: {
          matchId: { dataType: DT.Int32, isPartOfKey: true },
          matchIdentifier: { dataType: DT.String },
          predictionURL: { dataType: DT.String },
          probabilities: { dataType: DT.Undefined }
        },
        navigationProperties: {
          footballMatch: {
            entityTypeName: 'FootballMatch', isScalar: true,
            associationName: 'FootballMatch_FootballPrediction',
            foreignKeyNames: ['matchId']
          }
        }
      });

      metadataStore.addEntityType({
        shortName: 'FootballOdds',
        namespace: 'Samurai',
        dataProperties: {
          matchId: { dataType: DT.Int32, isPartOfKey: true },
          matchIdentifier: { dataType: DT.String },
          couponURL: { dataType: DT.Undefined },
          homeWin: { dataType: DT.Undefined },
          draw: { dataType: DT.Undefined },
          awayWin: { dataType: DT.Undefined }
        },
        navigationProperties: {
          footballMatch: {
            entityTypeName: 'FootballMatch', isScalar: true,
            associationName: 'FootballMatch_FootballOdds',
            foreignKeyNames: ['matchId']
          }
        }
      });

      metadataStore.addEntityType({
        shortName: 'TennisMatch',
        namespace: 'Samurai',
        dataProperties: {
          matchIdentifier: { dataType: DT.String },
          id: { dataType: DT.Int64, isPartOfKey: true },
          tournament: { dataType: DT.String },
          year: { dataType: DT.String },
          matchDate: { dataType: DT.DateTime },

          playerAFirstName: { dataType: DT.String },
          playerASurname: { dataType: DT.String },
          playerBFirstName: { dataType: DT.String },
          playerBSurname: { dataType: DT.String },

          scoreLine: { dataType: DT.String },
        },
        navigationProperties: {
          predictions: {
            entityTypeName: 'TennisPrediction',
            isScalar: true,
            associationName: 'TennisMatch_TennisPrediction'
          }
        }
      });

      metadataStore.addEntityType({
        shortName: 'TennisPrediction',
        namespace: 'Samurai',
        dataProperties: {
          matchId: { dataType: DT.Int32, isPartOfKey: true },
          matchIdentifier: { dataType: DT.String },
          predictionURL: { dataType: DT.String },
          playerAGames: { dataType: DT.Double },
          playerBGames: { dataType: DT.Double },
          ePoints: { dataType: DT.Double },
          eGames: { dataType: DT.Double },
          eSets: { dataType: DT.Double },
          probabilities: { dataType: DT.Undefined },
          scoreLineProbabilties: { dataType: DT.Undefined }
        },
        navigationProperties: {
          tennisMatch: {
            entityTypeName: 'TennisMatch', isScalar: true,
            associationName: 'TennisMatch_TennisPrediction',
            foreignKeyNames: ['matchId']
          }
        }
      });

      metadataStore.addEntityType({
        shortName: 'TennisOdds',
        namespace: 'Samurai',
        dataProperties: {
          matchId: { dataType: DT.Int32, isPartOfKey: true },
          matchIdentifier: { dataType: DT.String },
          couponURL: { dataType: DT.Undefined },
          homeWin: { dataType: DT.Undefined },
          awayWin: { dataType: DT.Undefined }
        },
        navigationProperties: {
          footballMatch: {
            entityTypeName: 'TennisMatch', isScalar: true,
            associationName: 'TennisMatch_TennisOdds',
            foreignKeyNames: ['matchId']
          }
        }
      });
    }

    function registerEntityTypeConstructors(metadataStore) {

      metadataStore.registerEntityTypeCtor('TennisMatch', null, tennisMatchInitialiser);
      metadataStore.registerEntityTypeCtor('FootballMatch', null, footballMatchIntitialiser);
    }

    function footballMatchIntitialiser(footballMatch) {
      footballMatch.matchTime = ko.computed(function () {
        var start = footballMatch.matchDate();
        var value = ((start - nulloDate) === 0) ?
                        ' --- ' :
                        (start && moment.utc(start).isValid()) ?
                            moment.utc(start).format('DD-MM-YY HH:mm') :
                            ' --- ';
        return value;
      });

      footballMatch.homeWinProb = ko.computed(function () {
        var probs = footballMatch.predictions().probabilities();
        return probs && ((100 * probs['homeWin']).toFixed(0) + '%');
      });

      footballMatch.drawProb = ko.computed(function () {
        var probs = footballMatch.predictions().probabilities();
        return probs && ((100 * probs['draw']).toFixed(0) + '%');
      });

      footballMatch.awayWinProb = ko.computed(function () {
        var probs = footballMatch.predictions().probabilities();
        return probs && ((100 * probs['awayWin']).toFixed(0) + '%');
      });
    }

    function footballOddsIntialiser(footballOdds) {

      footballOdds.homeWinImplicitProbability = ko.computed(function () {
        return footballOdds.homeWin().decimalOdds() ? (1 / footballOdds.homeWin().decimalOdds()) : 0.0;
      });

      footballOdds.drawImplicitProbability = ko.computed(function () {
        return footballOdds.draw().decimalOdds() ? (1 / footballOdds.draw().decimalOdds()) : 0.0;
      });

      footballOdds.awayWinImplicitProbability = ko.computed(function () {
        return footballOdds.awayWin().decimalOdds() ? (1 / footballOdds.awayWin().decimalOdds()) : 0.0;
      });

      tennisOdds.homeWinImplicitProbabilityText = ko.computed(function () {
        return (100 * homeWinImplicitProbability()).toFixed(0) + '%';
      });

      tennisOdds.drawImplicitProbabilityText = ko.computed(function () {
        return (100 * drawImplicitProbability()).toFixed(0) + '%';
      });

      tennisOdds.awayWinImplicitProbability = ko.computed(function () {
        return (100 * awayWinImplicitProbability()).toFixed(0) + '%';
      });

    }

    function tennisMatchInitialiser(tennisMatch) {

      tennisMatch.playerAFullName = ko.computed(function () {
        return tennisMatch.playerASurname() + ', ' + tennisMatch.playerAFirstName();
      });

      tennisMatch.playerBFullName = ko.computed(function () {
        return tennisMatch.playerBSurname() + ', ' + tennisMatch.playerBFirstName();
      });

      tennisMatch.matchTime = ko.computed(function () {
        var start = tennisMatch.matchDate();
        var value = ((start - nulloDate) === 0) ?
                        ' --- ' :
                        (start && moment.utc(start).isValid()) ?
                            moment.utc(start).format('DD-MM-YY HH:mm') :
                            ' --- ';
        return value;                      
      });

      tennisMatch.playerAWinProb = ko.computed(function () {
        var probs = tennisMatch.predictions().probabilities();
        return probs && ((100 * probs['homeWin']).toFixed(0) + '%');
      });

      tennisMatch.playerBWinProb = ko.computed(function () {
        var probs = tennisMatch.predictions().probabilities();
        return probs && ((100 * probs['awayWin']).toFixed(0) + '%');
      });
    }

    function tennisOddsIntialiser(tennisOdds) {

      tennisOdds.homeWinImplicitProbability = ko.computed(function () {
        return tennisOdds.homeWin().decimalOdds() ? (1 / tennisOdds.homeWin().decimalOdds()) : 0.0;
      });

      tennisOdds.awayWinImplicitProbability = ko.computed(function () {
        return tennisOdds.awayWin().decimalOdds() ? (1 / tennisOdds.awayWin().decimalOdds()) : 0.0;
      });

      tennisOdds.homeWinImplicitProbabilityText = ko.computed(function () {
        return (100 * homeWinImplicitProbability()).toFixed(0) + '%';
      });

      tennisOdds.awayWinImplicitProbability = ko.computed(function () {
        return (100 * awayWinImplicitProbability()).toFixed(0) + '%';
      });

    }


    //#endregion

  });