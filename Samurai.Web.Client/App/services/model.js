define(['config'],
  function (config) {
    var DT = breeze.DataType;
    var AutoGeneratedKeyType = breeze.AutoGeneratedKeyType;
    var nulloDate = new Date(1900, 0, 1);

    var model = {
      configureMetadataStore: configureMetadataStore
    };

    return model;

    function configureMetadataStore(metadataStore) {
      entityTypeInitialiser(metadataStore);
      registerEntityTypeConstructors(metadataStore);
    }

    //#region Private variables
    function entityTypeInitialiser(metadataStore) {
      metadataStore.addEntityType({
        shortName: 'FootballMatch',
        namespace: 'Samurai',
        dataProperties: {
          matchIdentifier: { dataType: DT.String },
          id: { dataType: DT.Int64, isPartOfKey: true },
          league: { dataType: DT.String },
          season: { dataType: DT.String },
          matchDate: { dataType: DT.DateTime },
          homeTeam: { dataType: DT.String },
          awayTeam: { dataType: DT.String },
          scoreLine: { dataType: DT.String },
          iktsGameWeek: { dataType: DT.Int64 },
        },
        navigationProperties: {
          predictions: {
            entityTypeName: 'FootballPrediction',
            isScalar: true,
            associationName: 'FootballMatch_FootballPrediction'
          },
          odds: {
            entityTypeName: 'FootballOdds',
            isScalar: true,
            associationName: 'FootballMatch_FootballOdds'
          }
        }
      });

      metadataStore.addEntityType({
        shortName: 'FootballPrediction',
        namespace: 'Samurai',
        dataProperties: {
          matchId: { dataType: DT.Int32, isPartOfKey: true },
          matchIdentifier: { dataType: DT.String },
          predictionURL: { dataType: DT.String },
          probabilities: { dataType: DT.Undefined }
        },
        navigationProperties: {
          footballMatch: {
            entityTypeName: 'FootballMatch', isScalar: true,
            associationName: 'FootballMatch_FootballPrediction',
            foreignKeyNames: ['matchId']
          }
        }
      });

      metadataStore.addEntityType({
        shortName: 'FootballOdds',
        namespace: 'Samurai',
        dataProperties: {
          matchId: { dataType: DT.Int32, isPartOfKey: true },
          matchIdentifier: { dataType: DT.String },
          couponURL: { dataType: DT.Undefined },
          homeWin: { dataType: DT.Undefined },
          draw: { dataType: DT.Undefined },
          awayWin: { dataType: DT.Undefined }
        },
        navigationProperties: {
          footballMatch: {
            entityTypeName: 'FootballMatch', isScalar: true,
            associationName: 'FootballMatch_FootballOdds',
            foreignKeyNames: ['matchId']
          }//,

          //homeWin: {
          //  entityTypeName: 'FootballOdd', isScalar: false,
          //  associationName: 'FootballOdds_FootballOdd'
          //},
          //draw: {
          //  entityTypeName: 'FootballOdd', isScalar: false,
          //  associationName: 'FootballOdds_FootballOdd'
          //},
          //awayWin: {
          //  entityTypeName: 'FootballOdd', isScalar: false,
          //  associationName: 'FootballOdds_FootballOdd'
          //}

        }
      });

      metadataStore.addEntityType({
        shortName: 'FootballOdd',
        namespace: 'Samurai',
        dataProperties: {
          matchId: { dataType: DT.Int32 },
          outcome: { dataType: DT.String },
          oddsBeforeCommission: { dataType: DT.Decimal },
          commissionPct: { dataType: DT.Decimal },
          decimalOdds: { dataType: DT.Decimal },
          timeStamp: { dataType: DT.DateTime, isPartOfKey: true },
          bookmaker: { dataType: DT.String, isPartOfKey: true },
          oddsSource: { dataType: DT.String, isPartOfKey: true },
          clickThroughURL: { dataType: DT.String },
          priority: { dataType: DT.Int32 }
        },
        navigationProperties: {
          odds: {
            entityTypeName: 'FootballOdds', isScalar: true,
            associationName: 'FootballOdds_FootballOdd',
            foreignKeyNames: ['matchId']
          }
        }
      });

      metadataStore.addEntityType({
        shortName: 'TennisMatch',
        namespace: 'Samurai',
        dataProperties: {
          matchIdentifier: { dataType: DT.String },
          id: { dataType: DT.Int64, isPartOfKey: true },
          tournament: { dataType: DT.String },
          year: { dataType: DT.String },
          matchDate: { dataType: DT.DateTime },

          playerAFirstName: { dataType: DT.String },
          playerASurname: { dataType: DT.String },
          playerBFirstName: { dataType: DT.String },
          playerBSurname: { dataType: DT.String },

          scoreLine: { dataType: DT.String },
        },
        navigationProperties: {
          predictions: {
            entityTypeName: 'TennisPrediction',
            isScalar: true,
            associationName: 'TennisMatch_TennisPrediction'
          },
          odds: {
            entityTypeName: 'TennisOdds',
            isScalar: true,
            associationName: 'TennisMatch_TennisOdds'
          }
        }
      });

      metadataStore.addEntityType({
        shortName: 'TennisPrediction',
        namespace: 'Samurai',
        dataProperties: {
          matchId: { dataType: DT.Int32, isPartOfKey: true },
          matchIdentifier: { dataType: DT.String },
          predictionURL: { dataType: DT.String },
          playerAGames: { dataType: DT.Double },
          playerBGames: { dataType: DT.Double },
          ePoints: { dataType: DT.Double },
          eGames: { dataType: DT.Double },
          eSets: { dataType: DT.Double },
          probabilities: { dataType: DT.Undefined },
          scoreLineProbabilties: { dataType: DT.Undefined }
        },
        navigationProperties: {
          tennisMatch: {
            entityTypeName: 'TennisMatch', isScalar: true,
            associationName: 'TennisMatch_TennisPrediction',
            foreignKeyNames: ['matchId']
          }
        }
      });

      metadataStore.addEntityType({
        shortName: 'TennisOdds',
        namespace: 'Samurai',
        dataProperties: {
          matchId: { dataType: DT.Int32, isPartOfKey: true },
          matchIdentifier: { dataType: DT.String },
          couponURL: { dataType: DT.Undefined },
          homeWin: { dataType: DT.Undefined },
          awayWin: { dataType: DT.Undefined }
        },
        navigationProperties: {
          tennisMatch: {
            entityTypeName: 'TennisMatch', isScalar: true,
            associationName: 'TennisMatch_TennisOdds',
            foreignKeyNames: ['matchId']
          }//,
          //homeWin: {
          //  entityTypeName: 'TennisOdd', isScalar: false,
          //  associationName: 'TennisOdds_TennisOdd'
          //},
          //awayWin: {
          //  entityTypeName: 'TennisOdd', isScalar: false,
          //  associationName: 'TennisOdds_TennisOdd'
          //}
        }
      });

      metadataStore.addEntityType({
        shortName: 'TennisOdd',
        namespace: 'Samurai',
        dataProperties: {
          matchId: { dataType: DT.Int32 },
          outcome: { dataType: DT.String },
          oddsBeforeCommission: { dataType: DT.Decimal },
          commissionPct: { dataType: DT.Decimal },
          decimalOdds: { dataType: DT.Decimal },
          timeStamp: { dataType: DT.DateTime, isPartOfKey: true },
          bookmaker: { dataType: DT.String, isPartOfKey: true },
          oddsSource: { dataType: DT.String, isPartOfKey: true },
          clickThroughURL: { dataType: DT.String },
          priority: { dataType: DT.Int32 }
        },
        navigationProperties: {
          odds: {
            entityTypeName: 'TennisOdds', isScalar: true,
            associationName: 'TennisOdds_TennisOdd',
            foreignKeyNames: ['matchId']
          }
        }
      });

    }

    function registerEntityTypeConstructors(metadataStore) {

      metadataStore.registerEntityTypeCtor('TennisMatch', null, tennisMatchInitialiser);
      metadataStore.registerEntityTypeCtor('FootballMatch', null, footballMatchIntitialiser);
      metadataStore.registerEntityTypeCtor('TennisOdds', null, tennisOddsIntialiser);
      metadataStore.registerEntityTypeCtor('FootballOdds', null, footballOddsIntialiser);
    }

    function footballMatchIntitialiser(footballMatch) {

      footballMatch.matchTime = ko.computed(function () {
        var start = footballMatch.matchDate();
        var value = ((start - nulloDate) === 0) ?
                        ' --- ' :
                        (start && moment.utc(start).isValid()) ?
                            moment.utc(start).format('DD-MM-YY HH:mm') :
                            ' --- ';
        return value;
      });

      footballMatch.homeWinProb = ko.computed(function () {
        var probs = footballMatch.predictions().probabilities();
        return probs && ((100 * probs['homeWin']).toFixed(0) + '%');
      });

      footballMatch.drawProb = ko.computed(function () {
        var probs = footballMatch.predictions().probabilities();
        return probs && ((100 * probs['draw']).toFixed(0) + '%');
      });

      footballMatch.awayWinProb = ko.computed(function () {
        var probs = footballMatch.predictions().probabilities();
        return probs && ((100 * probs['awayWin']).toFixed(0) + '%');
      });
    }

    function footballOddsIntialiser(footballOdds) {

      footballOdds.homeWinBestOdds = ko.computed(function () {
        var x = footballOdds.homeWin()[0];//.decimalOdd;
        return (x && x.hasOwnProperty('decimalOdd')) ? x.decimalOdd : '';
      });

      footballOdds.homeWinImplicitProbability = ko.computed(function () {
        return footballOdds.homeWin().decimalOdd ? (1 / footballOdds.homeWin().decimalOdd) : 0.0;
      });

      footballOdds.drawImplicitProbability = ko.computed(function () {
        return footballOdds.draw().decimalOdd ? (1 / footballOdds.draw().decimalOdd) : 0.0;
      });

      footballOdds.awayWinImplicitProbability = ko.computed(function () {
        return footballOdds.awayWin().decimalOdd ? (1 / footballOdds.awayWin().decimalOdd) : 0.0;
      });

      footballOdds.homeWinImplicitProbabilityText = ko.computed(function () {
        return (100 * footballOdds.homeWinImplicitProbability()).toFixed(0) + '%';
      });

      footballOdds.drawImplicitProbabilityText = ko.computed(function () {
        return (100 * footballOdds.drawImplicitProbability()).toFixed(0) + '%';
      });

      footballOdds.awayWinImplicitProbabilityText = ko.computed(function () {
        return (100 * footballOdds.awayWinImplicitProbability()).toFixed(0) + '%';
      });

    }

    function tennisMatchInitialiser(tennisMatch) {

      tennisMatch.hasOdds = ko.computed(function () {
        if (tennisMatch.hasOwnProperty('odds') && tennisMatch.odds()) {
          var odds = tennisMatch.odds();

        }
      });

      tennisMatch.playerAFullName = ko.computed(function () {
        return tennisMatch.playerASurname() + ', ' + tennisMatch.playerAFirstName();
      });

      tennisMatch.playerBFullName = ko.computed(function () {
        return tennisMatch.playerBSurname() + ', ' + tennisMatch.playerBFirstName();
      });

      tennisMatch.matchTime = ko.computed(function () {
        var start = tennisMatch.matchDate();
        var value = ((start - nulloDate) === 0) ?
                        ' --- ' :
                        (start && moment.utc(start).isValid()) ?
                            moment.utc(start).format('DD-MM-YY HH:mm') :
                            ' --- ';
        return value;                      
      });

      tennisMatch.playerAWinProb = ko.computed(function () {
        var probs = tennisMatch.predictions().probabilities();
        return probs && ((100 * probs['homeWin']).toFixed(0) + '%');
      });

      tennisMatch.playerBWinProb = ko.computed(function () {
        var probs = tennisMatch.predictions().probabilities();
        return probs && ((100 * probs['awayWin']).toFixed(0) + '%');
      });
    }

    function tennisOddsIntialiser(tennisOdds) {

      tennisOdds.homeWinImplicitProbability = ko.computed(function () {
        var homeWin = tennisOdds.homeWin()[0];
        return (homeWin !== undefined && homeWin.decimalOdd) ? (1 / homeWin.decimalOdd) : 0.0;
      });

      tennisOdds.awayWinImplicitProbability = ko.computed(function () {
        var awayWin = tennisOdds.awayWin()[0];
        var match = tennisOdds.tennisMatch();
        return (awayWin !== undefined && awayWin.decimalOdd) ? (1 / awayWin.decimalOdd) : 0.0;
      });

      tennisOdds.homeWinImplicitProbabilityText = ko.computed(function () {
        return (100 * tennisOdds.homeWinImplicitProbability()).toFixed(0) + '%';
      });

      tennisOdds.awayWinImplicitProbabilityText = ko.computed(function () {
        return (100 * tennisOdds.awayWinImplicitProbability()).toFixed(0) + '%';
      });

    }


    //#endregion

  });